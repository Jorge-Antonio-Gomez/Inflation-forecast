
<!-- HEAD -->
# Datos y Entorno


```{r, message = FALSE, warning = FALSE, echo = FALSE, results = "hide"}
# To clear the environment:
  # rm(list = ls())

# Librerías
  # install.packages(c("readxl", "dplyr", "ggplot2", "forecast"))
  # install.packages(tseries)

library(readxl)
library(dplyr)
library(ggplot2)
library(forecast)
library(tseries)
```


```{r}
getwd() # "C:/Users/antonio.gomez/Desktop/inf-forecast"
setwd("E:/CIDE/Series de Tiempo/Inflation forecast")

# Import from base.xslx:
data <- read_excel("base.xlsx")
  tail(data)

# Renombrar columnas:
colnames(data) <- c("fecha", "expect_t", "expect_t1", "inflation")

# Data frame with expect_t e inflation:
df <- data.frame(data$fecha, data$expect_t, data$inflation, data$expect_t1)
  colnames(df) <- c("fecha", "expect_t", "inflation", "expect_t1")
  tail(df)

# get data from:
start_year = 2000

# Take data from start_year (df have text as YYYY/MM/DD):
df <- filter(df, as.numeric(format(df$fecha, "%Y")) >= start_year)
  # tail(df)
  
# Convertir a serie de tiempo con fechas:
ts_inflation <- ts(df$inflation, start = c(start_year, 1), frequency = 12)
ts_expect_t  <- ts(df$expect_t,  start = c(start_year, 1), frequency = 12)
ts_expect_t1 <- ts(df$expect_t1, start = c(start_year, 1), frequency = 12)

currentYear <- as.numeric(format(df$fecha[dim(df)[1]], "%Y"))
```

# Análisis Exploratorio

## Determinar la precisión con la que el signo de la expectativas de inflación coincide con el signo de la inflación observada.

Expectativas con $\delta \pi^e_t <= 0.11$ son 50% precisas con respecto a la inflación observada.


```{r, eval = FALSE}
# Filter rows with values <= 0.11:
df <- filter(df, expect_t <= 0.11, expect_t >= -0.11, inflation <= 0.11, inflation >= -0.11)
  tail(df)

# a vector that saves the sign of each difference:
df$sign_diff_expect_t <- ifelse(df$expect_t >= 0, 1, -1) # 1 if inflation is increasing, -1 if decreasing
  # head(df)
  # tail(df)

df$sign_diff_inflation <- ifelse(df$inflation >= 0, 1, -1) # 1 if inflation is increasing, -1 if decreasing
  # head(df)
  # tail(df)

valid_expectation <- df$sign_diff_inflation == df$sign_diff_expect_t

# Porcentajes:
correct_expectation <- sum( na.omit(valid_expectation) == TRUE ) / length(na.omit(valid_expectation)) * 100
wrong_expectation <- sum( na.omit(valid_expectation) == FALSE ) / length(na.omit(valid_expectation)) * 100


# For all data
cbind(correct_expectation, wrong_expectation)
```

¿Qué modelo es mejor utilizar?

## Función de autocorrelación `ACF()`:

```{r}
years = currentYear - start_year
months = years * 12
# ACF (no partial) monthly:
acf(na.omit(ts_inflation), lag.max = months, main = "ACF Inflation")
```



# Forecasting

## Modelo con 12 dummies

El modelo que ejucateremos es el siguiente:


Modelo 1:

$$
\pi_{t} = \mu + \beta_1 \pi_{t-1} + \sum_{i=1}^{12} \gamma_{i} D_i + \varepsilon_t
$$


Modelo 2 (pendiente):

$$
\pi_{t} = \mu + \beta_1 \pi_{t-1} + \beta_2 \pi_{t-12} + \beta_2 \pi_{t-24} + \sum_{i=1}^{12} \gamma_{i} D_i + \varepsilon_t
$$

### Modelo 1

Creación de rezagos y dummies:
```{r}
# Inflation lag:
df$inflation_lag <- c(NA, df$inflation[1:dim(df)[1]-1])

# Crear dummies:
df$month <- as.numeric(format(df$fecha, "%m"))

# Crear dummies:
for (i in 1:12) {
  df[paste0("D_", i)] <- ifelse(df$month == i, 1, 0)
}

nrow(df)

# df sin la última fila:
df_reduced <- df[1:dim(df)[1]-1,]
nrow(df_reduced)
df_last <- df[dim(df)[1],]

# head(df)
```

```{r}
# Modelo:
model <- lm(inflation ~ inflation_lag + D_1 + D_2 + D_3 + D_4 + D_5 + D_6 + D_7 + D_8 + D_9 + D_10 + D_11 + D_12, data = df_reduced)
summary(model)
```


```{r}
# Forecast para el siguiente periodo:
forecast_inflation <- forecast(model, h = 1, level = 0.90, newdata = df_last)
forecast_inflation
```



## AUTO.ARIMA

Analizando los datos con un AUTO.ARIMA

```{r, eval = FALSE}
# AUTO.ARIMA:
auto.arima(ts_inflation)
```

## Gráfica de la serie:

```{r}
plot_1 <- ggplot() +
  geom_line(data = ts_inflation, aes(x = time(ts_inflation), y = ts_inflation), color = "black") +
  labs(title = "Inflation Series", x = "Time", y = "Inflation") +
  # trimestralmente:
  scale_x_continuous(breaks = seq(start_year, 2024, 1)) +
  theme_minimal()

# To show plot as pdf:
ggsave("plot_times_series.pdf", plot = plot_1, width = 10, height = 5)
plot_1
```


```{r}
# Time series de 2015 a 2024 (con for):

# prev horizon (¿Qué tan al pasado quiere observar? (en años))
horizon <- 10 # since 2015

# Horizon year:
horizonYear <- currentYear - horizon


for (i in 1:12) {
  assign(paste0("ts_inflation_", horizonYear), window(ts_inflation, start = c(horizonYear, 1), end = c(horizonYear, 12)), envir = .GlobalEnv)
}
```

Gráfica:

```{r}
# Plotear todas las series superpuestas (sin contar la general)
ggplot() +
  geom_line(data = ts_inflation_2014, aes(x = 1:12, y = ts_inflation_2015), color = "pink") +
  geom_line(data = ts_inflation_2015, aes(x = 1:12, y = ts_inflation_2015), color = "black") +
  geom_line(data = ts_inflation_2016, aes(x = 1:12, y = ts_inflation_2016), color = "gray") +
  geom_line(data = ts_inflation_2017, aes(x = 1:12, y = ts_inflation_2017), color = "purple") +
  geom_line(data = ts_inflation_2018, aes(x = 1:12, y = ts_inflation_2018), color = "blue") +
  geom_line(data = ts_inflation_2019, aes(x = 1:12, y = ts_inflation_2019), color = "green") +
  geom_line(data = ts_inflation_2020, aes(x = 1:12, y = ts_inflation_2020), color = "brown") + # Pandemia
  geom_line(data = ts_inflation_2021, aes(x = 1:12, y = ts_inflation_2021), color = "purple") +
  geom_line(data = ts_inflation_2022, aes(x = 1:12, y = ts_inflation_2022), color = "orange") +
  geom_line(data = ts_inflation_2023, aes(x = 1:12, y = ts_inflation_2023), color = "black") +
  geom_line(data = ts_inflation_2024, aes(x = 1:4, y = ts_inflation_2024), color = "red", lwd = 1.5) +
  # linea en y = 0:
  geom_hline(yintercept = 0, color = "black", linetype = "dashed") +
  # labels
  labs(title = "Inflation Forecasting", x = "Month", y = "Inflation") +
  # De 1 en 1 en x:
  scale_x_continuous(breaks = seq(1, 12, 1)) +
  # Label for each line:
  theme_minimal()

# Plot desde horizonYear in cicle:

```

## ARIMA(2,0,0)[12]

```{r}
# ARIMA(2,0,0)[12]:
  # model_arima_2 <- Arima(ts_inflation, order = c(2,0,0), seasonal = list(order = c(0,0,0), period = 12))
  # model_arima_2
```



## Submuestras

```{r}
# Create subSamples:
inSample <- window(ts_inflation, end = c(2022, 3))
outSample <- window(ts_inflation, start = c(2022, 4))
outSampleExpectation <- window(ts_expect_t, start = c(2022, 4))
```



## ARIMA(0,1,0)[12] con Out-of-sample = 24

```{r}
# ARIMA(2,0,0)[12]:
 # model_arima_2 <- Arima(inSample, order = c(2,0,0), seasonal = list(order = c(0,0,0), period = 12))

# Forecast one step ahead:
  # forecast_arima_2 <- forecast(model_arima_2, h = 24)
  # forecast_arima_2

# Integrate the observed to the inSample (A PATA):
forecast_rw <- rep(NA, 25)
for (i in 1:25) {
  inSample <- window(ts_inflation, end = c(2022, 2 + i))
  # print(paste0("c(2022, ", 2 + i, ")"))
  model_rw <- Arima(inSample, order = c(0,1,0), seasonal = list(order = c(0,0,0), period = 1))
  # model_arima_2 <- Arima(inSample, order = c(2,0,0), seasonal = list(order = c(0,0,0), period = 12))
  forecast_rw[i] <- forecast(model_rw, h = 1)$mean
}


df_forecast <- data.frame(time = time(forecast_rw), forecast_rw)
  colnames(df_forecast) <- c("time", "forecast_rw")
  tail(df_forecast)
```


## Función de cualquier modelo ARIMA con Out-of-sample = m


```{r}
# IN FUNCTION:
   # serie: i.e. ts_inflation  (Time series data)
   # modelname: i.e. arima_2   (Name of the model)
   # order: i.e. c(2,0,0)      (ARIMA order)
   # outSampleSize: i.e. 24    (Tamaño de la muestra de validación)
   # period: i.e. 12           (1 if you don't want deterministic seasonality)
   # h: i.e. 1                 (1 if you want to forecast one step ahead)

iterate_forecast <- function(serie, model_name, order, period, outSampleSize, h) {
  # Number of forecasts:
  nfcast <- outSampleSize + h
  
  # Start year of the forecast (using nfcast):
  lastMonth <- end(serie)[2]
  startYearToFcast <- floor(currentYear + ((lastMonth)/12) - ((outSampleSize)/12) )
  start_month_index <- lastMonth - (outSampleSize %% 12)
  end_month_index <- start_month_index - 1
  
    if (start_month_index <= 0) {
      start_month_index <- 12 + start_month_index
      end_month_index <- start_month_index - 1
      startYearToFcast <- startYearToFcast - 1
    }
  
  
  
  # Create a vector to save the forecast:
  forecast_vector <- rep(NA, nfcast)
  
  # Cicle
  for (i in 1:nfcast) {
    print(paste0("Final de la in-Sample: c(", startYearToFcast, ", ", end_month_index - h + i, ")"))
    inSample <- window(serie, end = c(startYearToFcast, end_month_index - h + i))
    model <- Arima(inSample, order = order, seasonal = list(order = c(0,0,0), period = period))
    
    forecast_vector[i] <- forecast(model, h = h)$mean
    # print(forecast_vector[i])
  }
  
  # Date of the out-of-sample:
  Date <- seq(as.Date(paste0(startYearToFcast, "-", end_month_index + 1, "-01")), by = "month", length.out = nfcast)
  assign("Date", Date, envir = .GlobalEnv)
  
  # convert `forecast_vector` to a time series:
  forecast_vector <- ts(forecast_vector, start = c(startYearToFcast, end_month_index + 1), frequency = 12)
  
  # Create a data frame with the forecast:
  assign(paste0("forecast_", model_name), forecast_vector, envir = .GlobalEnv)
  
  # Creación de un outSample_observed y un outSample_expected and declare them as global variables:
  assign("outSample_observed", window(serie, start = c(startYearToFcast, end_month_index + 1)), envir = .GlobalEnv)
  assign("outSample_expected", window(ts_expect_t, start = c(startYearToFcast, end_month_index + 1)), envir = .GlobalEnv)
  
  return(forecast_vector)
  # El output es una serie de tiempo con las predicciones llamada forecast_"model_name", donde "model_name" es el nombre del modelo.
}

# 
iterate_forecast(ts_inflation, "rw", c(0,1,0), 1, 24, 1)
iterate_forecast(ts_inflation, "arima100", c(2,0,0), 12, 24, 1)

forecast_arima200
forecast_1 <- forecast_arima100
```

```{r}
# Plot de la predicción (con intervalos de confianza) y de los datos reales (outSample):
time <- Date

plot_2 <- ggplot() +
  geom_line(data = forecast_1, aes(x = time, y = forecast_1), color = "orange", linetype = "dashed") +
  # geom_line(data = forecast_arima200, aes(x = time, y = forecast_arima200), color = "brown", linetype = "dashed") +
  # geom_line(data = df_forecast, aes(x = time, y = forecast_arima_2$lower[ ,2]), color = "red") +
  # geom_line(data = df_forecast, aes(x = time, y = forecast_arima_2$upper[ ,2]), color = "red") +
  
  # Datos observados:
  geom_line(data = outSample_observed, aes(x = time, y = outSample_observed), color = "black") +
  
  # Expectativa de los datos observados:
  geom_line(data = outSample_expected, aes(x = time, y = outSample_expected), color = "gray", linetype = "dashed") +
  
  # Título y ejes:
  labs(title = "ARIMA Forecasting", x = "Time", y = "Inflation") +
  # Línea en y = 0:
  geom_hline(yintercept = 0, color = "black", linetype = "dashed") +
  # Put the legend at the bottom:
  # theme(legend.position = "bottom") +
  
  # Otras cosas:
  # Forecastito (cuatro valores):
  # geom_line(data = forecastito, aes(x = forecastito_time, y = forecastito), color = "darkgreen", linetype = "dashed") +
  
  # X ticks mensuales y rotados 90 grados:
  scale_x_date(date_labels = "%b %Y", date_breaks = "1 month") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme_minimal()

# pdf saved and opened:
ggsave("plot_2.pdf", plot_2, width = 10, height = 6)
plot_2

```

### RMSFE

```{r}
# Forecast de abril de 2024:
forecast_arima_2[25]
```

```{r}
# Quitar último elemento (abr 2024):
outSample <- window(outSample, end = c(2024, 3))
forecast_arima_2 <- window(forecast_arima_2, end = c(2024, 3))
outSampleExpectation <- window(outSampleExpectation, end = c(2024, 3))

cbind(length(outSample), length(forecast_arima_2), length(outSampleExpectation))

# RMSFE del forecast:
RMSFE_arima_2 <- sqrt(mean((outSample - forecast_arima_2)^2))
RMSFE_expectation <- sqrt(mean((outSample - outSampleExpectation)^2))

rmsfe_df <- data.frame(RMSFE_arima_2, RMSFE_expectation)
  rmsfe_df
```


## ARIMA(0,1,0)

```{r}
# ARIMA(0,1,0) not seasonal:
model_rw <- Arima(ts_inflation, order = c(0,1,0))
  model_rw
```

